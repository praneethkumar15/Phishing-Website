# encoding: utf-8
# module _random
# from (built-in)
# by generator 1.147
# no imports
# no functions
# classes
class Random(object):
 def getrandbits(self, k): # real signature unknown; restored from __doc__
 """ getrandbits(k) -> x. Generates an int with k random bits. """
 pass
 def getstate(self): # real signature unknown; restored from __doc__
 """ getstate() -> tuple containing the current state. """
 return ()
class __loader__(object):
 @classmethod
 def create_module(cls, *args, **kwargs): # real signature unknown
 pass
 @classmethod
 def exec_module(cls, *args, **kwargs): # real signature unknown
 
 pass
 @classmethod
 def is_package(cls, *args, **kwargs): # real signature unknown
 pass
 @classmethod
 def load_module(cls, *args, **kwargs): # real signature unknown
 pass
 def module_repr(module): # reliably restored by inspect
 pass
 def __init__(self, *args, **kwargs): # real signature unknown
 pass
 __weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None) # 
default
 __dict__ = None # (!) real value is "mappingproxy({'__module__': '_frozen_importlib', 
'__doc__': 'Meta path import for built-in modules.\\n\\n All methods are either class or static 
methods to avoid the need to\\n instantiate the class.\\n\\n ', 'module_repr': <staticmethod 
object at 0x0000023150816FC8>'exec_module': <classmethod object at 
0x000002315081E108>, 'get_code': <classmethod object at 0x000002315081E188>, 
'get_source': <classmethod object at 0x000002315081E208>, 'is_package': <classmethod 
object at 0x000002315081E288>, 'load_module': <classmethod object at 
0x000002315081E2C8>, '__dict__': <attribute '__dict__' of 'BuiltinImporter' objects>, 
'__weakref__': <attribute '__weakref__' of 'BuiltinImporter' objects>})"
